# Zillending Protocol

## Core Contract

### User transitions

Transitions that called by users via UI.

| Name | Type | Description |
| ---------------| ----------|---------|
| `deposit`         | `reverse: ByStr20, amount: Uint128` | deposit the underlying asset into the reserve. |
| `borrow` | | |
| `redeem` | | |
| `repay` | | |


### Admin transitions

Transitions that called by admin-cli.

| Name | Type | Description |
| ---------------| ----------|---------|
| `set_configurator`         | `configurator: ByStr20` | changes configurator address. |
| `init_reserve`         | `reserve: ByStr20, underlying_asset_decimals: Uint256, interest_rate_strategy_address: ByStr20, aToken_address: ByStr20, reserve_name: String, reserve_symbol: String` | initializes a reserve |
| `set_reserve_interest_rate_strategy_address` | `reserve: ByStr20, rate_strategy_address: ByStr20` | updates the address of the interest rate strategy contract |
| `enable_borrowing_on_reverse` | `reserve: ByStr20, stable_borrow_rate_enabled: Bool` | enables borrowing on a reserve. Also sets the stable rate borrowing |
| `disable_borrowing_on_reverse` | `reserve: ByStr20` | disables borrowing on a reserve |


## AToken Contract

### Internal Functions

*We might need some temporary fields for internal communication, try not use it, but sometimes we have to*

| Name | Type | Description |
| ---------------| ----------|---------|
| `calculate_cumulated_balance_internal`         | `user: ByStr20, balance: Uint256, reserve_normalized_income: Uint256` | calculate the interest accrued by user on a specific balance. `reserve_normalized_income` should be calculated by core contract, but we now need use oracle server as the lacking of the external library feature. |
| `balance_of` | `user: ByStr20, reserve_normalized_income: Uint256` | calculate the balance of the user, whihc is the principal balance + interest generated by the principal balance + interest generated by the redirected balance |


### Transitions

| Name | Type | Description |
| ---------------| ----------|---------|
| `mint_on_deposit`         | `account: ByStr20, amount: Uint256, reserve_normalized_income: Uint256` | Only can be called by core contract. Mints token in the event of the users depositing the underlying asset into the lending pool. |

## Stragety Contract

We deploy one strategy contract for every reserve added. The stragety (see following) fields are fetched by core contract via remote read.

### Fields

| Name | Type | Description |
| ---------------| ----------|---------|
| `base_variable_borrow_rate`         | `Uint256` | base variable borrow rate when Utlization rate = 0. Expressed in ray. |
| `variable_rate_slope1`         | `Uint256` | slope of the variable interest curve when utilization rate > 0 and <= optimal_utilization_rate. Expressed in ray. |
| `variable_rate_slope2`         | `Uint256` | slope of the variable interest curve when utilization rate > optimal_utilization_rate. Expressed in ray. |
| `stable_rate_slope1`         | `Uint256` | slope of the stable interest curve when utilization rate > 0 and <= optimal_utilization_rate. Expressed in ray. |
| `stable_rate_slope2`         | `Uint256` | slope of the stable interest curve when utilization rate > optimal_utilization_rate. Expressed in ray. |


## Formula

### Constants

```
let wad = Uint256 1000000000000000000
let half_wad = Uint256 500000000000000000
let ray = Uint256 1000000000000000000000000000
let half_ray = Uint256 500000000000000000000000000
let wad_ray_ratio = Uint256 1000000000
```

### Linear Interest

```
Parameters: rate, last_update_timestamp

1. time_difference = current_timestamp - last_update_timestamp
2. time_delta = time_difference.way_to_ray().ray_div(seconds_per_year.wad_to_ray())
3. rate.ray_mul(time_delta).add(ray)
```

### Compounded Interest

```
Parameters: rate, last_update_timestamp

1. time_difference = current_timestamp - last-update_timestamp
2. rate_per_second = rate.div(seconds_per_year)
3. rate_per_second.add(ray).ray_pow(time_difference)
```


## Oracle Mechanism

1. oracle server is the verifier of the contracts.
2. oracle server uses schnorr algorithm to sign the hash of the message.
3. contract side use oracle server's public key to verify the hash of the message, further, extra parameters from the message.


```
procedure verifySignature(msg: String, sign: ByStr64)
  data_to_verify = builtin sha256hash msg;
  pubk <- verifier;
  e = {_eventname: "RawDataToVerifySignature"; data_to_verify: data_to_verify; sign: sign; pubk: pubk};
  event e;
  data = builtin to_bystr data_to_verify;
  is_valid = builtin schnorr_verify pubk data sign;
  match is_valid with
    | True =>
      e2 = {_eventname: "SignatureValid"};
      event e2
    | False =>
      err = InvalidSignature;
      ThrowError err
  end
end
```